makeliblvg
    # 
    # run radex and make lib.lvg
    # 
    # Usage:
    #     sm
    #     macro read makeliblvg_subbeam_modeling.sm makeliblvg
    # 
    # Note:
    #     please note those <TODO> marks
    # 
    # Last Update:
    #     2015-03-02 dzliu
    #     2019-01-26 dzliu, added C_atom, now use X_species and S_species to fit 
    # 
    # 
    set z = 0.0 # 0.0 1.5 6.0
    set z_str = sprintf('%0.3f',z)
    set outNAME = {"lib_subbeam_modeling.lvg"} # <"lib_z_$(z_str)_subbeam_modeling.lvg">
    set dirRADEX = {"/Users/dzliu/Cloud/Github/Crab.Toolkit.michi2/data/make_lib_LVG/01_RadiativeTransferCode/RADEX"}
    set dirMKLIB = {"/Users/dzliu/Cloud/Github/Crab.Toolkit.michi2/data/make_lib_LVG/02_Make_Lib_LVG/makeliblvg_subbeam_modeling"}
    # 
    set nH = 1.0, 7.0, 0.1
    set Tk = 10.0, 50.0, 5.0
    set NL = 21.0, 24.0, 0.2
    # 
    set n_models = dimen(NL)*dimen(Tk)*dimen(nH)*16
    !echo -n "Will make "$(n_models)' items for lib.lvg, '
    !echo "go!"
    !sleep 1.5
    #define OK y
    #define OK ? < OK ? [y/n] >
    #if(index('$OK','y')<0){
    #    echo "Aborted by the user!"
    #    return
    #}
    # 
    # constants 
    set k_B = 1.380658e-16 # Boltzmann constant CGS erg K-1
    set h_0 = 6.6260755e-27 # Planck constant CGS erg s
    set v_c = 2.99792458e10 # cm/s
    set g_0 = 6.672e-11
    set G_N = 4.302e-3 # (pc/solar mass) (km/s)^2
    set tkc = 2.0*k_B/v_c/v_c
    # 
    load astroSfig.sm
    set dL = 10.0 # Mpc # calc_lumdist(z)
    set dA = 10.0 # Mpc # dL/((1.+z)**2)
    # 
    # Note:
    #   I_CO to molecular gas 
    #   According to Solomon 2005 ARAA Eq(2)
    #   L'_CO = \int T_b * d_V * Omega_s * D_A^2 = I_CO / (1+z) [K km s-1] * Omega_s * D_A^2, the 1/(1+z) converts I_CO from obs-frame to rest-frame. 
    #   But here when we make the model, we have to make the redshift fixed, therefore we *(1+z) to convert model flux to obs-frame. And when analyzing the fits, we do not need to convert it back. 
    # 
    !test -d $(dirRADEX)
    if($exit_status!=0) {
        echo mkdir -p $(dirRADEX)
        !mkdir -p $(dirRADEX)
        if($exit_status!=0) {
            echo "Error! Failed to create the working directory! "$(dirRADEX)
            exit
        }
    }
    !pwd
    CHDIR $(dirRADEX)
    !pwd
    # 
    # make radex output dir if not exist
    !test -d "out"
    if($exit_status!=0) {
        echo mkdir "out"
        !mkdir "out"
        if($exit_status!=0) {
            echo "Error! Failed to create the radex out directory! No write permission under the radex directory? "$(dirRADEX)
            exit
        }
    }
    # 
    !date +"\#\ %Y-%m-%d\ %H:%M:%S" > "lib.lvg"
    print +"lib.lvg" '\# NVAR  = 2 \# Variable X Y\n' {}
    print +"lib.lvg" '\# TVAR1 = X_species\n' {}
    print +"lib.lvg" '\# TVAR2 = S_species, assumed emitting source area 1.0 kpc^2, obs-frame flux density, in unit of Jy km/s. \n' {}
    print +"lib.lvg" '\# CVAR1 = 1 \# X_species == ID_{species} + J_{upper}\n' {}
    print +"lib.lvg" '\# CVAR2 = 2 \# S_species == T_RJ * 2 k nu^2/c^2 * DeltaV * emitting_solid_angle * (1+z), in unit of Jy km/s. \n' {}
    print +"lib.lvg" '\# NVAR1 = 19 \# CO J=1-0 to J=16-15 and CI J=3P2-3P1 and J=3P1-3P0 J=3P2-3P0 \n' {}
    print +"lib.lvg" '\# NVAR2 = $(dimen(NL)*dimen(Tk)*dimen(nH)) \# combination of all indepedent parameters\n' {}
    print +"lib.lvg" '\# NPAR  = 16 \# Parameter 1 2 3 ...\n' {}
    print +"lib.lvg" '\# TPAR1 = N_{H_2} \# H2 column density \n' {}
    print +"lib.lvg" '\# TPAR2 = T_{kin} \# gas kinetic temperature \n' {}
    print +"lib.lvg" '\# TPAR3 = n_{H_2} \# H2 volume density \n' {}
    print +"lib.lvg" '\# TPAR4 = ID_{species} \# 1000 for CO, 1001 for C_atom, etc.\n' {}
    print +"lib.lvg" '\# TPAR5 = Name_{species} \# CO, C_atom, etc.\n' {}
    print +"lib.lvg" '\# TPAR6 = J_{upper} \# upper energy level number\n' {}
    print +"lib.lvg" '\# TPAR7 = J_{lower} \# lower energy level number\n' {}
    print +"lib.lvg" '\# TPAR8 = tau \# optical depth of this transition of J_{upper} -> J_{lower}\n' {}
    print +"lib.lvg" '\# TPAR9 = T_{ex} \n' {}
    print +"lib.lvg" '\# TPAR10 = T_{RJ} \n' {}
    print +"lib.lvg" '\# TPAR11 = X_{species} \n' {}
    print +"lib.lvg" '\# TPAR12 = d{V}/d{r} \n' {}
    print +"lib.lvg" '\# TPAR13 = d{V} \n' {}
    print +"lib.lvg" '\# TPAR14 = N_{H_2} \# column number density \n' {}
    print +"lib.lvg" '\# TPAR15 = M_{H_2} \# assuming emitting source area 1.0 kpc^2, including Helium. \n' {}
    print +"lib.lvg" '\# TPAR16 = M_{dyn} \# for a single virialized cloud with radius d{r} = dv/dvddr [pc]. \n' {}
    print +"lib.lvg" '\# NPAR1 = $(dimen(NL))\n' {}
    print +"lib.lvg" '\# NPAR2 = $(dimen(Tk))\n' {}
    print +"lib.lvg" '\# NPAR3 = $(dimen(nH))\n' {}
    print +"lib.lvg" '\# NPAR4 = 1 \# this PAR is non-indepedent\n' {}
    print +"lib.lvg" '\# NPAR5 = 1 \# this PAR is non-indepedent\n' {}
    print +"lib.lvg" '\# NPAR6 = 1 \# this PAR is non-indepedent\n' {}
    print +"lib.lvg" '\# NPAR7 = 1 \# this PAR is non-indepedent\n' {}
    print +"lib.lvg" '\# NPAR8 = 1 \# this PAR is non-indepedent\n' {}
    print +"lib.lvg" '\# NPAR9 = 1 \# this PAR is non-indepedent\n' {}
    print +"lib.lvg" '\# NPAR10 = 1 \# this PAR is non-indepedent\n' {}
    print +"lib.lvg" '\# NPAR11 = 1 \# this PAR is non-indepedent\n' {}
    print +"lib.lvg" '\# NPAR12 = 1 \# this PAR is non-indepedent\n' {}
    print +"lib.lvg" '\# NPAR13 = 1 \# this PAR is non-indepedent\n' {}
    print +"lib.lvg" '\# NPAR14 = 1 \# this PAR is non-indepedent\n' {}
    print +"lib.lvg" '\# NPAR15 = 1 \# this PAR is non-indepedent\n' {}
    print +"lib.lvg" '\# NPAR16 = 1 \# this PAR is non-indepedent\n' {}
    print +"lib.lvg" '\# CPAR1 = 3 \# column number of this PAR\n' {}
    print +"lib.lvg" '\# CPAR2 = 4 \# column number of this PAR\n' {}
    print +"lib.lvg" '\# CPAR3 = 5 \# column number of this PAR\n' {}
    print +"lib.lvg" '\# CPAR4 = 6 \# column number of this PAR\n' {}
    print +"lib.lvg" '\# CPAR5 = 7 \# column number of this PAR\n' {}
    print +"lib.lvg" '\# CPAR6 = 8 \# column number of this PAR\n' {}
    print +"lib.lvg" '\# CPAR7 = 9 \# column number of this PAR\n' {}
    print +"lib.lvg" '\# CPAR8 = 10 \# column number of this PAR\n' {}
    print +"lib.lvg" '\# CPAR9 = 11 \# column number of this PAR\n' {}
    print +"lib.lvg" '\# CPAR10 = 12 \# column number of this PAR\n' {}
    print +"lib.lvg" '\# CPAR11 = 13 \# column number of this PAR\n' {}
    print +"lib.lvg" '\# CPAR12 = 14 \# column number of this PAR\n' {}
    print +"lib.lvg" '\# CPAR13 = 15 \# column number of this PAR\n' {}
    print +"lib.lvg" '\# CPAR14 = 16 \# column number of this PAR\n' {}
    print +"lib.lvg" '\# CPAR15 = 17 \# column number of this PAR\n' {}
    print +"lib.lvg" '\# CPAR16 = 18 \# column number of this PAR\n' {}
    print +"lib.lvg" '\# \n' {}
    print +"lib.lvg" '\# ' {}
    print +"lib.lvg" 'X_species        S_species    lg_N_H2      T_kin    lg_n_H2' {}
    print +"lib.lvg" '   ID_species    Name_species    J_upper    J_lower' {}
    print +"lib.lvg" '          tau       T_ex       T_RJ' {}
    print +"lib.lvg" '    Abundance    dvddr       dv' {}
    print +"lib.lvg" '     column_N_H2         mass_H2  mass_dyn_cloud' {}
    print +"lib.lvg" '\n' {}
    define ii 0
    # 
    # Parameter order: Tk nH, therefore we first loop nH (slower) then loop Tk (faster)
    # 
    foreach nHOne nH {
        foreach TkOne Tk {
            foreach NLOne NL {
                # 
                # Virial Thereom
                # 
                # sigma = alpha_vir * 3.25 * (10**NH2_/62e20)**0.5 * (R/60)**0.5
                set R_ = ((10**$NLOne)/3e18)/(10**$nHOne)/2.0
                #set alpha_vir = 2.0
                #set dVDoW = alpha_vir * 3.25 * ((10**$NLOne)/62e20)**0.5 * (R_/60.0)**0.5
                set dVDoW = 7.1 * ((10**$NLOne)/62e20)**0.47 * (R_/60.0)**0.47
                set dvddr = dVDoW / (2.0*R_) # for a fixed nHOne, dVDoW/R ~ (NLOne/R)**0.5 is a constant!
                define dVDoW $(dVDoW)
                define dvddr $(dvddr)
                # 
                # Debug Test
                #define dVDoW 10.0 #<DEBUG><TEST>#
                # 
                # RADEX acceptable line width can not be larger than 1e3, it must be between 1e-3 and 1e3
                if(dVDoW>1e3) {
                    set dVDoW = 1e3
                    define dVDoW $(dVDoW)
                }
                if(dVDoW<1e-3) {
                    set dVDoW = 1e-3
                    define dVDoW $(dVDoW)
                }
                # 
                # CO
                # 
                define NXAbD 5e-5   # <TODO> CO Abundance, see Dannerbauer 2009 Sec.4 where they fix NXAbD/dvddr=1E-5, also see Riechers 2010 AzTEC-3 Sec.4.2
                                    # <TODO> CO to H2 abundance, 8eâˆ’5 (Frerking et al. 1982), used by ZhangZY+2014. The helium mass is included in M(H2). 
                #define dvddr 5.0    # <TODO> see Weiss 2007 APM08297 Fig.8 Caption, or Weiss 2007 ASPC Sect. 3.2 first paragraph, where they fix NXAbD/dvddr=1E-5. 
                #                    # <TODO> ZhangZY+2014 Circinus dv/dr best-fit is 3.0 km/s/pc. 
                #                    # <TODO> Curran et al. (2001) fitted dv/dr for Circinus and found 10.0 km/s/pc. 
                #define dVDoW 50.0   # <TODO> Turbulence Doppler Line Width correlated with Dense Core Sizes 
                #                    # <TODO> 
                define TbCMB $(2.73*(1+z))  # <TODO> T_{CMB} = 2.73 * (1+z) # http://www.astronomy.ohio-state.edu/~dhw/A873/notes4.pdf
                #define NHLoS $($dVDoW/$dvddr*(10**$nHOne)*3.086e18) # column density of H_2 gas in cm-2. 
                define NHLoS $(10**$NLOne) # column density of H_2 gas in cm-2. 
                define NXLoS $($NHLoS*$NXAbD) # column density of H_2 gas in cm-2. 
                print  "inp/co.inp" './data/co.dat\n' {}
                print +"inp/co.inp" './out/co_""$nHOne"_"$TkOne"_"$NLOne".out"\n' {}
                print +"inp/co.inp" '100 1900\n' {} # Freq Range to include CO J=1-0 to J=16-15
                print +"inp/co.inp" '$TkOne\n' {} # Tk
                print +"inp/co.inp" '2\n' {}
                print +"inp/co.inp" 'o-H2\n' {}
                print +"inp/co.inp" '$(0.75*(10**$nHOne))\n' {} # 0.75 ortho-H2 see Dannerbauer 2009 BzK
                print +"inp/co.inp" 'p-H2\n' {}
                print +"inp/co.inp" '$(0.25*(10**$nHOne))\n' {} # 0.25 para-H2 see Dannerbauer 2009 BzK
                print +"inp/co.inp" '$TbCMB\n' {} # T_{CMB} at z~1.5 Dannerbauer
           #    print +"inp/co.inp" '$NHLoS\n' {} # Column H2 Density along Line of Sight -- NHLoS
                print +"inp/co.inp" '$NXLoS\n' {} # Column CO Density along Line of Sight -- NXLoS
                print +"inp/co.inp" '$dVDoW\n' {} # Velocity Corresponding to Doppler Width -- dVDoW
                print +"inp/co.inp" '0\n' {}
                # 
                !test -f "out/co_"$nHOne"_"$TkOne"_"$NLOne".out"
                if($exit_status==0) {
                    !rm "out/co_"$nHOne"_"$TkOne"_"$NLOne".out"
                }
                # 
                echo ./bin/radex < inp/co.inp > out/co_$nHOne"_"$TkOne"_"$NLOne.log
                !    ./bin/radex < inp/co.inp > out/co_$nHOne"_"$TkOne"_"$NLOne.log
                # 
                !test -f "out/co_"$nHOne"_"$TkOne"_"$NLOne".out"
                if($exit_status!=0) {
                    echo "Error! Failed to run radex and output the data file \"""out/co_"$nHOne"_"$TkOne"_"$NLOne".out""\""
                    set J_UP = {1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16}
                    set J_LOW = {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15}
                    set E_UP = {5.5 16.6 33.2 55.3 83.0 116.2 154.9 199.1 248.9 304.2 365.0 431.3 503.1 580.5 663.4 751.7}
                    set FREQ = {115.2712 230.5380 345.7960 461.0408 576.2679 691.4731 806.6518 921.7997 1036.9124 1151.9855 1267.0145 1381.9951 1496.9229 1611.7935 1726.6025 1841.3455}
                    set WAVE = {2600.7576 1300.4037 866.9634 650.2515 520.2310 433.5562 371.6504 325.2252 289.1203 260.2398 236.6133 216.9273 200.2725 185.9993 173.6314 162.8116}
                    set T_RJ = J_UP * 0.0
                    set T_EX = J_UP * 0.0
                    set TAU = J_UP * 0.0
                    set FLUX1 = J_UP * 0.0
                } else {
                    data "out/co_"$nHOne"_"$TkOne"_"$NLOne".out" lines 14 0 read {J_UP 1 DASH 2.s J_LOW 3 E_UP 4 FREQ 5 WAVE 6 T_EX 7 TAU 8 T_RJ 9 FLUX1 12}
                }
                # 
                set NLArr = T_RJ*0.0+$NLOne
                set TkArr = T_RJ*0.0+$TkOne
                set nHArr = T_RJ*0.0+$nHOne
                set emArr = T_RJ*0.0+0.0
                set Sline = T_RJ * tkc * (FREQ*1e9)**2 * 1.0645*$dVDoW * 1e23 # T_RJ * 2 k nu^2/c^2 * DeltaV
                                                                              # in unit of Jy km/s sr-1
                                                                              # 1.0645 see radex_manual.pdf sec.4.3
                set Name_species_1 = (J_UP>0) ? 'CO' : 'CO'
                set ID_species_1 = (J_UP>0) ? 101 : 101 # We assign CO an ID of 101
                set J_UP_species_1 = J_UP
                set J_LOW_species_1 = J_LOW
                set X_species_1 = ID_species_1*1e6 + J_UP_species_1*1e3 + J_LOW_species_1
                set S_species_1 = Sline
                set NL_species_1 = NLArr
                set TK_species_1 = TkArr
                set nH_species_1 = nHArr
                set TAU_species_1 = TAU
                set TEX_species_1 = T_EX
                set TRJ_species_1 = T_RJ
                set TbCMB_1 = J_UP*0.0 + $TbCMB
                set NHLoS_1 = J_UP*0.0 + $NHLoS
                set NXLoS_1 = J_UP*0.0 + $NXLoS
                set dvddr_1 = J_UP*0.0 + $dvddr
                set dVDoW_1 = J_UP*0.0 + $dVDoW
                set NXAbD_1 = J_UP*0.0 + $NXAbD
                # 
                # C_atom ([CI])
                # 
                define NXAbD 1.5e-5 # <TODO> CI Abundance, 
                                    # (https://arxiv.org/pdf/1111.4029.pdf) found 0.26 with CI and 13CO in CMZ clouds, when assuming Tkin=50K and lgnH2=3.5, or 0.47 by assuming Tkin=60K and lgnH2=3.6, or 0.37â€“0.47  if we adopt 40 instead of 24 as the 12C/13C ratio. 
                                    # 
                                    # NXAbD_CO/dvddr=1e-5, so NXAbD_C0/dvddr=1e-5*0.3=3e-6, so NXAbD_C0=3e-6*dvddr=1.5e-5
                                    # 
                define NXLoS $($NHLoS*$NXAbD)
                print  "inp/catom.inp" './data/catom.dat\n' {}
                print +"inp/catom.inp" './out/catom_""$nHOne"_"$TkOne"_"$NLOne".out"\n' {}
                print +"inp/catom.inp" '100 1900\n' {} # Freq Range to include CI J=3P2-3P1 and J=3P1-3P0
                print +"inp/catom.inp" '$TkOne\n' {} # Tk
                print +"inp/catom.inp" '2\n' {}
                print +"inp/catom.inp" 'o-H2\n' {}
                print +"inp/catom.inp" '$(0.75*(10**$nHOne))\n' {} # 0.75 ortho-H2 see Dannerbauer 2009 BzK
                print +"inp/catom.inp" 'p-H2\n' {}
                print +"inp/catom.inp" '$(0.25*(10**$nHOne))\n' {} # 0.25 para-H2 see Dannerbauer 2009 BzK
                print +"inp/catom.inp" '$TbCMB\n' {} # T_{CMB} at z~1.5 Dannerbauer
           #    print +"inp/catom.inp" '$NHLoS\n' {} # Column H2 Density along Line of Sight -- NHLoS
                print +"inp/catom.inp" '$NXLoS\n' {} # Column CI Density along Line of Sight -- NXLoS
                print +"inp/catom.inp" '$dVDoW\n' {} # Velocity Corresponding to Doppler Width -- dVDoW
                print +"inp/catom.inp" '0\n' {}
                # 
                !test -f "out/catom_"$nHOne"_"$TkOne"_"$NLOne".out"
                if($exit_status==0) {
                    !rm "out/catom_"$nHOne"_"$TkOne"_"$NLOne".out"
                }
                # 
                echo ./bin/radex < inp/catom.inp > out/catom_$nHOne"_"$TkOne"_"$NLOne.log
                !    ./bin/radex < inp/catom.inp > out/catom_$nHOne"_"$TkOne"_"$NLOne.log
                # 
                !test -f "out/catom_"$nHOne"_"$TkOne"_"$NLOne".out"
                if($exit_status!=0) {
                    echo "Error! Failed to run radex and output the data file \"""out/catom_"$nHOne"_"$TkOne"_"$NLOne".out""\"!"
                    set J_UP = {1 2 2}
                    set J_LOW = {0 1 0}
                    set E_UP = {23.6 62.5 62.5}
                    set FREQ = {492.1607 809.3420 1301.5026}
                    set WAVE = {609.1354 370.4151 230.3433}
                    set T_RJ = J_UP * 0.0
                    set T_EX = J_UP * 0.0
                    set TAU = J_UP * 0.0
                    set FLUX1 = J_UP * 0.0
                } else {
                    data "out/catom_"$nHOne"_"$TkOne"_"$NLOne".out" lines 14 0 read {J_UP 1 DASH 2.s J_LOW 3 E_UP 4 FREQ 5 WAVE 6 T_EX 7 TAU 8 T_RJ 9 FLUX1 12}
                }
                # 
                set NLArr = T_RJ*0.0+$NLOne
                set TkArr = T_RJ*0.0+$TkOne
                set nHArr = T_RJ*0.0+$nHOne
                set Sline = T_RJ * tkc * (FREQ*1e9)**2 * 1.0645*$dVDoW * 1e23 # T_RJ * 2 k nu^2/c^2 * DeltaV
                                                                              # in unit of Jy km/s
                                                                              # 1.0645 see radex_manual.pdf sec.4.3
                set Name_species_2 = (J_UP>0) ? 'C_atom' : 'C_atom'
                set ID_species_2 = (J_UP>0) ? 102 : 102 # We assign C_atom an ID of 102, the combined X_species will be 102,002,001 for [CI](2-1)
                set J_UP_species_2 = J_UP
                set J_LOW_species_2 = J_LOW
                set X_species_2 = ID_species_2*1e6 + J_UP_species_2*1e3 + J_LOW_species_2
                set S_species_2 = Sline
                set NL_species_2 = NLArr
                set TK_species_2 = TkArr
                set nH_species_2 = nHArr
                set TAU_species_2 = TAU
                set TEX_species_2 = T_EX
                set TRJ_species_2 = T_RJ
                set TbCMB_2 = J_UP*0.0 + $TbCMB
                set NHLoS_2 = J_UP*0.0 + $NHLoS
                set NXLoS_2 = J_UP*0.0 + $NXLoS
                set dvddr_2 = J_UP*0.0 + $dvddr
                set dVDoW_2 = J_UP*0.0 + $dVDoW
                set NXAbD_2 = J_UP*0.0 + $NXAbD
                # 
                # output
                # 
                set X_species = X_species_1 concat X_species_2
                set S_species = S_species_1 concat S_species_2
                set lg_N_H2 = NL_species_1 concat NL_species_2
                set T_kin = TK_species_1 concat TK_species_2
                set lg_n_H2 = nH_species_1 concat nH_species_2
                set ID_species = ID_species_1 concat ID_species_2
                set Name_species = Name_species_1 concat Name_species_2
                set J_UP = J_UP_species_1 concat J_UP_species_2
                set J_LOW = J_LOW_species_1 concat J_LOW_species_2
                set TAU = TAU_species_1 concat TAU_species_2
                set T_EX = TEX_species_1 concat TEX_species_2
                set T_RJ = TRJ_species_1 concat TRJ_species_2
                set T_CMB = TbCMB_1 concat TbCMB_2
                set columnN_H_2 = NHLoS_1 concat NHLoS_2
                set columnN_species = NXLoS_1 concat NXLoS_2
                set dv_ = dVDoW_1 concat dVDoW_2
                set dvddr_ = dvddr_1 concat dvddr_2
                set Abundance = NXAbD_1 concat NXAbD_2
                
                # 1 arcsec**2 = 2.350443054e-11 sr
                set r_cloud = float($dVDoW) / ($dvddr) # emitting source scale height in pc, assuming lvg cloud.
                set emitting_source_area = S_species * 0.0 + (r_cloud)**2 # TODO: assuming the emitting source area is (r_cloud)**2.
                set emitting_solid_angle = emitting_source_area / (dL*1e6)**2 # dL:Mpc->pc
                set S_species = S_species * emitting_solid_angle * (1.+z) # convert to obs-frame
                set h_cloud = float($dVDoW) / ($dvddr) # emitting source scale height in pc, assuming lvg cloud.
                set column_N_H_2 = float($dVDoW) / ($dvddr) * (10**lg_n_H2) * 3.086e18 # column density of H_2 gas in cm-2. 
                set mass_H_2_integ = column_N_H_2 * emitting_solid_angle
                #set mass_H_2_integ = pi*r_cloud**2 * h_cloud * 10**lg_n_H2 * 0.04980769993 # 0.04980769993 = 3.085677e18**3*3.3718047e-24/1.98892e33
                set r_cloud = S_species * 0.0 + h_cloud #<TODO># 
                set mass_dyn_cloud = r_cloud * (float($dVDoW)/2.35482)**2 / G_N # the dynamical mass from virial theory: M = R sigma**2 / G = R (dVDoW/2.35482)**2 / G
                #set N_cloud = mass_H_2_integ/mass_dyn_cloud
                #echo "r_cloud:" $(r_cloud[0]) "pc"
                #echo "h_cloud:" $(h_cloud[0]) "pc"
                #echo "column_N_H_2: "$(sprintf('%0.3e',column_N_H_2[0])) "cm-2"
                #echo "mass_H_2_integrated:" $(sprintf('%0.3e',mass_H_2_integ[0])) "solMass"
                #echo "mass_dyn_one_cloud:" $(sprintf('%0.3e',mass_dyn_cloud[0])) "solMass"
                #echo "number_of_clouds:" $(sprintf('%0.1f',mass_H_2_integ[0]/mass_dyn_cloud[0]))
                #exit
                # 
                define print_noheader 1
                print +"lib.lvg" '%-12.0f %15.6e %10.1f %10g %10.1f %12d %15s %10g %10g %12.3e %10g %10g %12.1e %8g %8g %15.6e %15.6e %15.6e\n' \
                                 {X_species S_species lg_N_H2 T_kin lg_n_H2 ID_species Name_species J_UP J_LOW TAU T_EX T_RJ Abundance dvddr_ dv_ column_N_H_2 mass_H_2_integ mass_dyn_cloud}
                # 
                #break
            }
            # 
            #break
        }
        # 
        #break
    }
    !pwd
    !mkdir -p $(dirMKLIB)
    CHDIR $(dirMKLIB)
    !pwd
    # 
    # copy
    echo cp $(dirRADEX)/lib.lvg $(outNAME)
    !cp $(dirRADEX)/lib.lvg $(outNAME)
    # 
    # end






