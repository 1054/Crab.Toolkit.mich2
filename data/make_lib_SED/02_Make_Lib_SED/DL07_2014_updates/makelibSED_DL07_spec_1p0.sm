makelibSED_DL07
    # 
    # Usage:
    #     sm # also need "https://github.com/1054/DeepFields.SuperDeblending/Softwares/Supermongo_macro"
    #     macro read makelibSED_DL07.sm makelibSED_DL07
    # 
    # Note:
    #     
    # 
    set nWav = 1001 # the DL07spec has 1001 wavelengths
    # 
    # 
    load astroSfig.sm
    # 
    # 
    #!gln -fsT /Users/dzliu/Softwares/CIGALE/cigale-v0.11.0-af9fd2dc7fc7dced5b816fd20582de00e3fbf08b/database_builder/dl2014 DL07spec
    !gln -fsT /Users/dzliu/Softwares/CIGALE/cigale-v0.12.1/database_builder/dl2014 DL07spec
    # 
    # 
    getDL07Spec
    # 
    # 
    #!echo -n "We will make "$(dimen(fPAH)*(dimen(fUmn))*$(nWav))' items for lib.SED, '
    #define OK ?
    #if(!$OK){
    #    echo Abort by user. 
    #    return
    #}
    # 
    # 
    writeLibHead "lib.DL07.2010.03.18.spec.1.0.LoExCom.SED"
    writeLibHead "lib.DL07.2010.03.18.spec.1.0.HiExCom.SED"
    # 
    # 
    # <20190128> column order Umin, qPAH, so first loop qPAH then loop Umin
    do jTMP = 0, dimen(fPAH)-1 {
        do iTMP = 0, dimen(fUmn)-1 {
            if ($iTMP==0&&$jTMP==0) {verbose 1} else {verbose 0}
            getDL07Spec $(fUmn[$iTMP]) $(fPAH[$jTMP])
            define print_noheader 1
            set dimen(fLoExUmn) = dimen(fLoExCom) set fLoExUmn[0,dimen(fLoExUmn)-1]=fUmn[$iTMP]
            set dimen(fHiExUmn) = dimen(fHiExCom) set fHiExUmn[0,dimen(fHiExUmn)-1]=fUmn[$iTMP]
            set dimen(fLoExPAH) = dimen(fLoExCom) set fLoExPAH[0,dimen(fLoExPAH)-1]=fPAH[$jTMP]
            set dimen(fHiExPAH) = dimen(fHiExCom) set fHiExPAH[0,dimen(fHiExPAH)-1]=fPAH[$jTMP]
            set dimen(fLoExDGR) = dimen(fLoExCom) set fLoExDGR[0,dimen(fLoExDGR)-1]=fDGR[$jTMP]
            set dimen(fHiExDGR) = dimen(fHiExCom) set fHiExDGR[0,dimen(fHiExDGR)-1]=fDGR[$jTMP]
            sort {lambda fLoExCom fLoExUmn fLoExPAH fLoExDGR fHiExCom fHiExUmn fHiExPAH fHiExDGR}
            set fLoExLTIR = lambda*0.0 + lg(calc_ltir(lambda,fLoExCom,0.0,8.0,1000.0,0.0001)) # grid 0.1 MHz
            set fHiExLTIR = lambda*0.0 + lg(calc_ltir(lambda,fHiExCom,0.0,8.0,1000.0,0.0001)) # grid 0.1 MHz
            set fLoExLFIR = lambda*0.0 + lg(calc_ltir(lambda,fLoExCom,0.0,40.0,400.0,0.0001)) # grid 0.1 MHz
            set fHiExLFIR = lambda*0.0 + lg(calc_ltir(lambda,fHiExCom,0.0,40.0,400.0,0.0001)) # grid 0.1 MHz
            print +"lib.DL07.2010.03.18.spec.1.0.LoExCom.SED" '%15.6e %14.6e %11.6f %11.6f %11.6f %11.6f %9.6f\n' {lambda fLoExCom fLoExUmn fLoExPAH fLoExLTIR fLoExLFIR fLoExDGR}
            print +"lib.DL07.2010.03.18.spec.1.0.HiExCom.SED" '%15.6e %14.6e %11.6f %11.6f %11.6f %11.6f %9.6f\n' {lambda fHiExCom fHiExUmn fHiExPAH fHiExLTIR fHiExLFIR fHiExDGR}
            undef print_noheader
        }
    }
    # 
    # end





getDL07Spec 02
    # 
    # macro read makelibSED.sm getDL07Spec Umin qPAH
    # 
    # 
    #[<20180301]#set tUmn = { "0.10" "0.15" "0.20" "0.30" "0.40" "0.50" "0.70" "0.80" \
    #[<20180301]#             "1.00" "1.20" "1.50" "2.00" "2.50" "3.00" "4.00" "5.00" "7.00" "8.00" \
    #[<20180301]#             "12.0" "15.0" "20.0" "25.0" }
    #[<20180301]#         #   "1e2" "3e2" "1e3" "3e3" "1e4" "3e4" "1e5" "3e5" }
    #[<20180301]#set tPAH = { "00" "10" "20" "30" "40" "50" "60" }
    #[<20180301]#set tDGR = { "0.01" "0.01" "0.0101" "0.0102" "0.0102" "0.0103" "0.0104" } # see Draine 2007 SINGS Table.3 M_dust/M_H
    #[<20180301]#set fPAH = { 0.47 1.12 1.77 2.50 3.19 3.90 4.58 }
    #[≥20180301]#
    #cd DL07Spec
    !ls -1 "DL07Spec" | gsort -V | sed -e 's/MW.*//g' | grep "1e7" | sed -e 's/_1e7_//g' | sed -e 's/^U//g' | uniq > list_of_Umin.txt
    !ls -1d "DL07Spec/"U50.00_50.00_MW3.1_* | gsort -V | sed -e 's/.*MW3.1_//g' > list_of_tPAH.txt
    #cd ../
    data "list_of_Umin.txt" read {tUmn 1.s}
    data "list_of_tPAH.txt" read {tPAH 1.s}
    set tDGR = { "0.01" "0.01" "0.0101" "0.0102" "0.0102" "0.0103" "0.0104" "0.0105" "0.0106" "0.0107" "0.0108" } # see Draine 2007 SINGS Table.3 M_dust/M_H. dzliu did some extrapolation....
    set fPAH = 0.00,0.10,0.01 # see "Aniano 2012 Dust Emission.pdf", Table 2, but I think their \Delta_{qPAH} should be 0.01 instead of 0.001
    set dimen(fUmn) = dimen(tUmn) do i=0,dimen(tUmn)-1 { set fUmn[$i] = float($(tUmn[$i])) }
    set dimen(fDGR) = dimen(tDGR) do i=0,dimen(tDGR)-1 { set fDGR[$i] = float($(tDGR[$i])) }
    define firstline 72 # see any "spec_1.0.dat"
    # 
    if( ($?1 && $?2) ) {
        set xUmn = $1
        set xPAH = $2
        set fDIF = abs(xUmn-fUmn) set iDIF = 0,dimen(fUmn)-1 sort {fDIF iDIF}
        set iUmn = iDIF[0]
        set fDIF = abs(xPAH-fPAH) set iDIF = 0,dimen(fPAH)-1 sort {fDIF iDIF}
        set iPAH = iDIF[0]
        #[<20180301]#set tDL07HiExDat = '\"'+'DL07spec/U'+'$(tUmn[iUmn])'+'/'+'U'+'$(tUmn[iUmn])'+'_1e6_MW3.1_'+'$(tPAH[iPAH])'+'.txt'+'\"'
        #[<20180301]#set tDL07LoExDat = '\"'+'DL07spec/U'+'$(tUmn[iUmn])'+'/'+'U'+'$(tUmn[iUmn])'+'_'+'$(tUmn[iUmn])'+'_MW3.1_'+'$(tPAH[iPAH])'+'.txt'+'\"'
        #[≥20180301]#
        set tDL07HiExDat = '\"'+'DL07spec/U'+'$(tUmn[iUmn])'+'_1e7_MW3.1_'+'$(tPAH[iPAH])'+'/spec_1.0.dat'+'\"'
        set tDL07LoExDat = '\"'+'DL07spec/U'+'$(tUmn[iUmn])'+'_'+'$(tUmn[iUmn])'+'_MW3.1_'+'$(tPAH[iPAH])'+'/spec_1.0.dat'+'\"'
        # if($verbose) {
        #     echo getDL07Spec: done!
        #     echo getDL07Spec: please read SED of low excitation component from $(tDL07LoExDat)
        #     echo getDL07Spec: and read SED of high excitation component from $(tDL07HiExDat)
        # }
        data $(tDL07HiExDat) lines $firstline 0 read {lambda 1 vfv 2 jv 3}     # lambda [um] ; vfv [erg/s/H] ; jv [Jy cm2 sr-1 H-1] ; H-1 means per H nucleon
        set jv4 = 4.0*pi*jv                                            # now jv4 is Jy cm^2 H^-1
        set vfv = vfv*1e23                                             # now vfv is Jy cm^2 H^-1 Hz^1
        set fv = vfv/2.99792458e8*lambda*1e-6                          # now fv == jv4 according to the README.txt under DL07spec
        set fv = fv*1e3                                                # now fv is mJy cm^2 H^-1 -- erg/s/Hz/H
        set Sv = fv*(1.98892e9/1.67262158/fDGR[iPAH])/(4.0*pi*9.52140) # (Mdust/DGR*1.98892e33/1.67262158e-24)/(4.0D*!PI*dL^2*9.52140e48) ; see Magdis2012 Eq.2
        set fHiExCom = Sv                                              # So flux[mJy] = fHiExCom * a1 = fHiExCom * Mdust / dL^2
        data $(tDL07LoExDat) lines $firstline 0 read {lambda 1 vfv 2 jv 3}     # lambda [um] ; vfv [erg/s/H] ; jv [Jy cm2 sr-1 H-1] ; H-1 means per H nucleon
        set jv4 = 4.0*pi*jv                                            # now jv4 is Jy cm^2 H^-1
        set vfv = vfv*1e23                                             # now vfv is Jy cm^2 H^-1 Hz^1
        set fv = vfv/2.99792458e8*lambda*1e-6                          # now fv == jv4 according to the README.txt under DL07spec
        set fv = fv*1e3                                                # now fv is mJy cm^2 H^-1 -- erg/s/Hz/H
        set Sv = fv*(1.98892e9/1.67262158/fDGR[iPAH])/(4.0*pi*9.52140) # (Mdust/DGR*1.98892e33/1.67262158e-24)/(4.0D*!PI*dL^2*9.52140e48) ; see Magdis2012 Eq.2
        set fLoExCom = Sv                                              # So flux[mJy] = fLoExCom * a1 = fLoExCom * Mdust / dL^2
        if($verbose) {
            echo getDL07Spec: done!
            echo getDL07Spec: now we have loaded two vectors fLoExCom and fHiExCom, 
            echo getDL07Spec: then the flux for each component is in unit of [mJy]
            echo getDL07Spec: can be derived by: 
            echo getDL07Spec:     fLoExCom = qPDR * fLoExCom * Mdust/dL^2 * (1+z)
            echo getDL07Spec:     fHiExCom = qPDR * fHiExCom * Mdust/dL^2 * (1+z)
            echo getDL07Spec: and the wavelength vector:
            echo getDL07Spec:     lambda = lambda * (1+z)
        }
        return
    } else {
        echo getDL07Spec: Usage: to get DL07 SED, please set 1st and 2nd argument to Umin and qPAH, 
        echo getDL07Spec:        e.g. getDL07Spec 1.0 0.35
        echo getDL07Spec:        when getDL07Spec without argument, only vectors tUmn tPAH tDGR are loaded. 
    }
    # 




writeLibHead 01
    # 
    # 
    # 
    !date +"\#\ %Y-%m-%d\ %H:%M:%S" > $1
    print +$1 '\# NVAR  = 2 \# Variable X Y\n' {}
    print +$1 '\# TVAR1 = band wavelengths (rest-frame) (lambda) [um]\n' {}
    print +$1 '\# TVAR2 = flux, in unit of mJy per dust mass in solar mass unit and Mpc^2\n' {}
    print +$1 '\# CVAR1 = 1 \# the colomn number of VAR1\n' {}
    print +$1 '\# CVAR2 = 2 \# the colomn number of VAR2\n' {}
    print +$1 '\# NVAR1 = $(nWav) \# NAXIS1\n' {}
    print +$1 '\# NVAR2 = $(dimen(fPAH)*dimen(fUmn)) \# NAXIS2\n' {}
    print +$1 '\# NPAR  = 5 \# Parameter 1 2 3 4 5\n' {}
    print +$1 '\# TPAR1 = Umin\n' {}
    print +$1 '\# TPAR2 = qPAH\n' {}
    print +$1 '\# TPAR3 = lgLTIR \# log of the integrated flux density (mJy*GHz) over rest-frame 8-1000 um\n' {}
    print +$1 '\# TPAR4 = lgLFIR \# log of the integrated flux density (mJy*GHz) over rest-frame 40-400 um\n' {}
    print +$1 '\# TPAR5 = fGDR\n' {}
    print +$1 '\# NPAR1 = $(dimen(fUmn))\n' {}
    print +$1 '\# NPAR2 = $(dimen(fPAH))\n' {}
    print +$1 '\# NPAR3 = 1 \# non-indepedent\n' {}
    print +$1 '\# NPAR4 = 1 \# non-indepedent\n' {}
    print +$1 '\# NPAR5 = 1 \# non-indepedent\n' {}
    print +$1 '\# CPAR1 = 3\n' {}
    print +$1 '\# CPAR2 = 4\n' {}
    print +$1 '\# CPAR3 = 5\n' {}
    print +$1 '\# CPAR4 = 6\n' {}
    print +$1 '\# CPAR5 = 7\n' {}
    print +$1 '\# \n' {}
    print +$1 '\#        lambda           flux        Umin        qPAH      lgLTIR      lgLFIR      fDGR\n' {}
    print +$1 '\#          [um]          [mJy]                           [mJy*GHz]   [mJy*GHz]          \n' {}
    return


